<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="caterpillarDev"/><link rel="canonical" href="caterpillarDev.github.io/posts/OCP"/><meta name="twitter:url" content="caterpillarDev.github.io/posts/OCP"/><meta name="og:url" content="caterpillarDev.github.io/posts/OCP"/><title>SOLID Principles - Open Closed Principle (1/2) | caterpillarDev</title><meta name="twitter:title" content="SOLID Principles - Open Closed Principle (1/2) | caterpillarDev"/><meta name="og:title" content="SOLID Principles - Open Closed Principle (1/2) | caterpillarDev"/><meta name="description" content="Personal blog."/><meta name="twitter:description" content="Personal blog."/><meta name="og:description" content="Personal blog."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/primer.css" type="text/css"/><link rel="stylesheet" href="/highlight.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to caterpillarDev"/></head><body><header><div class="border-bottom border-gray-light"><div class="container-md px-3 my-3 markdown-body"><h3><a class="text-gray-dark no-underline" href="/">caterpillar.dev</a></h3></div><div class="d-flex flex-justify-center"><p class="text-small text-gray v-align-middle">Reach me on <a href="https://www.linkedin.com/in/nikolamatijevic">LinkedIn</a> or <a href="https://twitter.com/nmatijevic1">Twitter</a></p></div></div></header><div class="container-md px-3 my-5 markdown-body"><p class="text-small text-gray">19 May 2020</p><p class="text-small text-gray">Reading time: 15mins</p><h1>SOLID Principles - Open Closed Principle (1/2)</h1><p>Setting a <strong>SOLID</strong> foundation is really hard, but in the end it has a huge payoff. After some time, you will understand that building a good foundation following these rules is even faster than building it without them. When you start noticing bottlenecks and where you broke these rules, you will see how much time you could have spared if they were properly implemented. If you never heard of SOLID before, I'd recommend reading my previous <a href="https://caterpillardev.com/posts/SRP/">article</a> which is an introduction to SOLID principles and an explanation of the first ( Single Responsibility ) principle.</p><h2>Open-Closed Principle ( OCP )</h2><p>OCP was defined back in 1988 by <a href="https://en.wikipedia.org/wiki/Bertrand_Meyer">Bertrand Meyer</a>:</p><blockquote><p><strong>“ A software artefact should be open for extension but closed for modification ”</strong></p></blockquote><p>What does this even mean? This principle says that adding new features to your code should require minimal effort possible. So, for example, if you are building a financial report app, adding a new report should not affect existing code. <strong>You shouldn't have to change existing code.</strong></p><p>In an ideal case, this means that you should only add code when building new features and put no effort into moving old ones around to make this possible. You have probably found yourself breaking this principle if you take a retroactive look. It's very important to accept mistakes and work on fixing them, rather than ignoring them.</p><h2>Example</h2><p>Let's iterate over the above-stated example of an app that generates financial reports. We are going to analyze a simple feature that generates a report in two forms - PDF or Web Report.</p><img src="/images/OCP_example_flow.png"/><h3><strong>PROBLEM</strong></h3><p>Here we can see a high-level overview of our feature. What our goal should be here is to structure source code so that changes in generating a PDF report don't affect the Web Report and vice versa.</p><p>If we take a look at our feature again, we can divide it into two segments: - report calculation - result presentation</p><h3><strong>SOLUTION</strong></h3><img src="/images/OCP.png"/><p>I know this looks scary, but I will break it down to the tiniest detail so that you can understand it as well as I do.</p><p>First, let's take a look at the arrows. If you take a closer look, you can notice two types of arrows (empty and filled top):</p><ul><li><strong>Empty top</strong> arrows represent <strong>conformance</strong> ( on the other side is always an <code>Interface/Protocol</code>)</li><li><strong>Filled top</strong> arrows represent <strong>dependency</strong> ( if class A points to class B, which means that class A has a reference to class B - usually in the form of a variable/constant). If you don't fully understand what is a <code>dependency</code>, you can check out <a href="https://www.quora.com/What-is-a-dependency-in-coding?share=1">this discussion</a>. Understanding dependencies is very important for else of this article, so I would suggest looking it up.</li></ul><p>The graph above shows us <strong>source code dependencies and relationships between objects</strong>. The whole flow is separated into four components, also called <code>layers</code>:</p><ul><li>Interactor/Use Case</li><li>Web server</li><li>Controller</li><li>Presenter/View</li></ul><p>These components are separated in double frame boxes. We will break down OCP into a set of rules:</p><ol><li>First important thing is that <strong>arrows leave a component in only one direction</strong>. This is also known as <code>unidirectional data flow</code>. Following this can highly increase you code quality and conformance to OCP.</li></ol><ol start="2"><li>Which direction should arrows point to? This is determined based on component stability. In our case, the most stable part of our feature is how we calculate the report. After some time doing analysis like this, you will notice that <code>the most stable part of your feature/app is logic that actually represents a business you are trying to automate</code>. In our example, this logic is encapsulated inside of the <strong>Interactor</strong> module. What you can notice that</li></ol><blockquote><p><strong>all the arrows point towards this module and none come out of it</strong>. This means that <strong>our logic has no dependencies and doesn't know that any other components exist</strong>.</p></blockquote><p>I cannot express the importance of this enough!</p><ol start="3"><li>Arrows are always pointing towards stable components. We can notice that the <code>Controller</code> is more stable than the <code>Presenter</code>, and that's why the Presenter has a dependency on the Controller layer. We never do direct dependencies between components, we always use <code>protocols</code> as wrappers. This has multiple reasons behind it, but for now it's really important to know that this highly increases testability and stability of your code.</li></ol><ol start="4"><li><strong>Arrows decide the importance</strong> of your components. In our case we can rank them as such:<ol><li>Interactor</li><li>Controller</li><li>Web server</li><li>Presenter</li></ol></li></ol><blockquote><p><strong>Dependencies determine privileges.</strong></p></blockquote><p>Let's take a look at protocols a bit and why they are positioned in the way they are. If we take a look at our Interactor, we can see that it has a dependency to the <code>DataProvider</code> <strong>interface</strong>. What is important is to &gt; never depend on concrete implementations, always point to abstractions.</p><p>What this allows us is not to depend on internal implementations of functions defined in protocols. As long as input (function attributes) and output (return type) are the same, the component that implements the protocol can be tested and even deployed separately.</p><h1>Conclusion</h1><p>This article covers in-depth theoretical analysis (highly applicable one). In my next article I will move into implementation, starting from the first described approach (one that breaks OCP) and explain how you could improve from there to respect this principle. I will also go into further detail about each layer and their responsibilities.</p><p>If some stuff here is not clear enough, feel free to reach me on <a href="https://www.linkedin.com/in/nikolamatijevic">LinkedIn</a> or <a href="https://twitter.com/nmatijevic1">Twitter</a> or even change my mind.</p><h1>References</h1><ul><li><a href="https://caterpillardev.com/posts/SRP/">SOLID introduction article</a></li><li><a href="https://en.wikipedia.org/wiki/Bertrand_Meyer">Bertrand Meyer</a></li><li><a href="https://www.quora.com/What-is-a-dependency-in-coding?share=1">Dependency explanation</a></li></ul></div><footer><div class="container-md px-3 my-5 markdown-body"><div class="d-flex flex-justify-center"><p class="text-small text-gray v-align-middle">Styled with <a href="https://primer.style">Primer</a> | Generated using <a href="https://github.com/johnsundell/publish">Publish</a> | Hosted on <a href="https://pages.github.com">GitHub Pages</a></p></div></div></footer></body></html>